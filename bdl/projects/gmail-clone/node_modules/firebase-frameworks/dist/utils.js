"use strict";
// Copyright 2022 Google LLC
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.findDependency = exports.getProjectPathFactory = exports.spawn = exports.exec = void 0;
const child_process_1 = require("child_process");
const path_1 = require("path");
const exec = (command, options = {}) => new Promise((resolve, reject) => (0, child_process_1.exec)(command, options, (error, stdout) => {
    if (error) {
        reject(error);
        return;
    }
    resolve(stdout.trim());
}));
exports.exec = exec;
const spawn = (command, args = undefined, options, stdoutCallback, stderrCallback) => new Promise((resolve, reject) => {
    const child = (0, child_process_1.spawn)(command, args, Object.assign(Object.assign({}, options), { stdio: 'pipe' })).on('close', (code) => {
        if (code === 0) {
            resolve();
        }
        else {
            reject();
        }
    });
    if (stdoutCallback)
        child.stdout.on('data', stdoutCallback);
    if (stderrCallback)
        child.stderr.on('data', stderrCallback);
});
exports.spawn = spawn;
const getProjectPathFactory = (config) => (...args) => { var _a; return (0, path_1.join)(process.cwd(), (_a = config.prefix) !== null && _a !== void 0 ? _a : '.', ...args); };
exports.getProjectPathFactory = getProjectPathFactory;
const findDependency = (name, cwd = process.cwd()) => {
    const result = (0, child_process_1.spawnSync)('npm', ['list', name, '--json', '--omit', 'dev'], { cwd });
    if (!result.stdout)
        return undefined;
    const json = JSON.parse(result.stdout.toString());
    const search = (searchingFor, dependencies = {}) => {
        for (const [name, dependency] of Object.entries(dependencies)) {
            if (name === searchingFor && dependency.resolved)
                return dependency;
            const result = search(searchingFor, dependency.dependencies);
            if (result)
                return result;
        }
        return null;
    };
    return search(name, json.dependencies);
};
exports.findDependency = findDependency;
